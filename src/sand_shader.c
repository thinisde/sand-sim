#include "sand_shader.h"

// GPU sand update pass: runs a vertical fall pass and two diagonal passes.
static const char *kSandUpdateFs =
    "#version 330\n"
    "in vec2 fragTexCoord;\n"
    "out vec4 finalColor;\n"
    "\n"
    "uniform sampler2D texture0;\n"
    "uniform float uGroundY; // screen-space Y (origin at top)\n"
    "uniform int uPassType; // 0 = vertical, 1 = diagonal\n"
    "uniform int uDiagDx;   // -1 or 1 for diagonal pass\n"
    "\n"
    "ivec2 texSize() { return textureSize(texture0, 0); }\n"
    "\n"
    "bool inBounds(ivec2 p) {\n"
    "  ivec2 s = texSize();\n"
    "  return p.x >= 0 && p.y >= 0 && p.x < s.x && p.y < s.y;\n"
    "}\n"
    "\n"
    "float sampleR(ivec2 p) {\n"
    "  ivec2 s = texSize();\n"
    "  vec2 uv = (vec2(p) + vec2(0.5)) / vec2(s);\n"
    "  return texture(texture0, uv).r;\n"
    "}\n"
    "\n"
    "float groundTexY() {\n"
    "  return float(texSize().y - 1) - uGroundY;\n"
    "}\n"
    "\n"
    "bool isSand(ivec2 p) {\n"
    "  if (!inBounds(p)) return false;\n"
    "  if (float(p.y) <= groundTexY()) return false;\n"
    "  return sampleR(p) > 0.5;\n"
    "}\n"
    "\n"
    "bool isSolid(ivec2 p) {\n"
    "  if (!inBounds(p)) return true;\n"
    "  if (float(p.y) <= groundTexY()) return true;\n"
    "  return sampleR(p) > 0.5;\n"
    "}\n"
    "\n"
    "bool canMoveDown(ivec2 src) {\n"
    "  return isSand(src) && !isSolid(src + ivec2(0, -1));\n"
    "}\n"
    "\n"
    "bool canMoveDiag(ivec2 src, int dx) {\n"
    "  return isSand(src) && isSolid(src + ivec2(0, -1)) &&\n"
    "         !isSolid(src + ivec2(dx, -1));\n"
    "}\n"
    "\n"
    "void main() {\n"
    "  ivec2 s = texSize();\n"
    "  vec2 uv = clamp(fragTexCoord, vec2(0.0), vec2(0.999999));\n"
    "  ivec2 p = ivec2(uv * vec2(s));\n"
    "\n"
    "  if (!inBounds(p) || float(p.y) <= groundTexY()) {\n"
    "    finalColor = vec4(0.0, 0.0, 0.0, 1.0);\n"
    "    return;\n"
    "  }\n"
    "\n"
    "  bool self = isSand(p);\n"
    "  bool nextOcc = self;\n"
    "\n"
    "  if (uPassType == 0) {\n"
    "    bool movesOut = canMoveDown(p);\n"
    "    bool movesIn = canMoveDown(p + ivec2(0, 1));\n"
    "    nextOcc = (self && !movesOut) || movesIn;\n"
    "  } else {\n"
    "    int dx = uDiagDx;\n"
    "    bool movesOut = canMoveDiag(p, dx);\n"
    "    bool movesIn = canMoveDiag(p + ivec2(-dx, 1), dx);\n"
    "    nextOcc = (self && !movesOut) || movesIn;\n"
    "  }\n"
    "\n"
    "  finalColor = nextOcc ? vec4(1.0) : vec4(0.0, 0.0, 0.0, 1.0);\n"
    "}\n";

const char *sand_update_fragment_shader(void) { return kSandUpdateFs; }
